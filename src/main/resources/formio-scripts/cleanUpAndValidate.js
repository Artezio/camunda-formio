'use strict';const arrayComponents=['datagrid'];function saveToResult(e,t){Array.isArray(t)?t.push({[e]:!0}):'object'==typeof t&&(t[e]=!0)}function extendResult(e,t,n){return arrayComponents.includes(e)?(n[t]=[{}],n[t][0]):(n[t]={},n[t])}function makeSchema(e,t){if(Array.isArray(e))e.forEach(e=>makeSchema(e,t));else if(null!==e&&'object'==typeof e)if(e.tree&&Array.isArray(e.components)){const n=extendResult(e.type,e.key,t);Array.isArray(n)?(n.push({}),e.components.forEach((e,t)=>{makeSchema(e,n[0])})):e.components.forEach(e=>makeSchema(e,n))}else if(e.input)saveToResult(e.key,t);else for(let n in e)'object'==typeof e[n]&&makeSchema(e[n],t)}function ArrayHasArray(e,t){return t.every(t=>e.includes(t))}function clearArrayOfPrimitiveTypes(e){const t=e.filter(e=>'object'==typeof e&&null!==e);e.splice(0,e.length,...t)}function removeUnmatchedObjects(e,t){const n=e.filter(e=>{const n=Object.keys(e);return t.some(e=>ArrayHasArray(Object.keys(e),n))});n.forEach((e,n)=>{'object'==typeof e&&stripUnknown(e,t[n])}),e.splice(0,e.length,...n)}function stripUnknown(e,t){if('object'==typeof e&&null!==e&&'object'==typeof t&&null!==t)if(Array.isArray(e))Array.isArray(t)||e.splice(0,e.length),clearArrayOfPrimitiveTypes(e),removeUnmatchedObjects(e,t);else for(let n in e)n in t||delete e[n],null!==t[n]&&'object'==typeof t[n]&&('object'!=typeof e[n]||null===e[n]?delete e[n]:stripUnknown(e[n],t[n]))}var cleanUpSubmission=function(e,t={}){const n=t.data,r={};return makeSchema(e,r),stripUnknown(n,r),{...t,data:n}},takeFromStdin=function(){const[e,t,n]=[`%1$s`,`%2$s`,`%3$s`];return[JSON.parse(e),JSON.parse(t),n]},putToStdout=function(e,...t){e(...t).then(e=>{try{e=JSON.stringify(e),console.info(e)}catch(e){console.error(e)}}).catch(e=>{console.error(e)})};let[form,submission]=takeFromStdin();const cleanData=cleanUpSubmission(form,submission);function promise(){return Promise.resolve(cleanData)}putToStdout(promise);